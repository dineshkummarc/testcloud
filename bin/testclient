#!/usr/bin/env php
<?php

require(dirname(__FILE__).'/../vendor/autoload.php');
require(dirname(__FILE__).'/../lib/Zmsg.php');
require(dirname(__FILE__).'/../lib/ANSIColor.php');

define('POLL_TIMEOUT', 1000);

$opts = new \Ergo\Console\Options($argv,array(
	'--help','-h','-v','--brief,-b','--connect=tcp://localhost:2224',
	'--slow,-s=null','--failonly,-f',':dir'
));

// show help
if($opts->has('-h','--help') || $opts->errors())
{
	$opts->printErrors();

	echo "\nusage: $argv[0] [workingdir] [..args]\n\n";

	echo " --help             : this documentation\n";
	echo " --connect addr     : connect to a specific broker, defaults to tcp://localhost:2224\n";
	echo " --brief -b         : display only a brief summary of each command\n";
	echo " --slow millis      : shows tests that take more than N milliseconds to run as slow\n";
	echo " --failonly -f      : show only failures\n";
	echo "\n";
	exit(1);
}

/**
 * Render a testcloud response
 * @return string
 */
function render_result($cmd, $resp, $brief=false, $slow=false)
{
	$c = new ANSIColor();

	$output = $resp->exitcode === 0
		? $c->bold_brightgreen("OK! ").$c->green("{$cmd} ")
		: $c->bold_red("FAIL({$resp->exitcode}) ").$c->red("{$cmd} ")
		;

	if($slow && $resp->time > $slow)
		$output .= $c->underline_red(sprintf("⌚%.2fms\n", $resp->time));
	else
		$output .= $c->white(sprintf("⌚%.2fms\n", $resp->time));

	if($brief) $output .= "{$resp->stdout}\n";

	return $output;
}

// test client
$context = new ZMQContext();
$client = new ZMQSocket($context, ZMQ::SOCKET_DEALER);
$client->setSockOpt(ZMQ::SOCKOPT_IDENTITY, trim(`hostname`)."#client".getmypid());
$client->connect($opts->value('--connect'));

if($opts->has('-v'))
	printf("Connecting to %s\n", $opts->value('--connect'));

$timer = microtime(true);
$commands = array();
$results = array();
$output = new ANSIColor();
$success = true;
$queued = array();

while(($line = trim(fgets(STDIN))) || count($queued) > 0)
{
	// buffer stdin commands
	if($line)
		$commands []= $line;

	$read = $write = array();
	$poll = new ZMQPoll();
	$poll->add($client, ZMQ::POLL_IN);

	if(count($commands))
		$poll->add($client, ZMQ::POLL_OUT);

	$poll->poll($read, $write, 1000);

	// read some replies
	foreach($read as $socket)
	{
		$line = $socket->recv();

		if(preg_match('/^RESULT (.+?)$/', $line, $m))
		{
			$resp = json_decode($m[1]);

			// in some failure scenarios, we get a 2+ responses
			if(!isset($queued[$resp->hash]))
				continue;

			$req = $queued[$resp->hash]->req;

			if($resp->exitcode !== 0 || !$opts->has('-f'))
				echo render_result($req->cmd, $resp, $opts->value('-b'), $opts->value('-s'));

			unset($queued[$resp->hash]);
			$results [$resp->hash] = $resp;
		}
		else if(preg_match('/^(WORKING|QUEUED) (.+?)$/', $line, $m))
		{
			// do nothing
		}
		else
		{
			die("Unknown response $line");
		}
	}

	// send some commands
	foreach($write as $socket)
	{
		$req = (object) array(
			'cmd'=>array_shift($commands), 'cwd'=>$opts->value(':dir') ?: getcwd()
		);

		if($opts->has('-v'))
			printf("Sending: {$req->cmd}\n");

		$json = json_encode($req);
		$socket->send($json);

		$hash = sha1($json);
		$queued[$hash] = (object) array('req'=>$req, 'sent'=>time());
	}
}

// calculate a summary
ksort($results);
$outputhash = NULL;

foreach($results as $result)
	$outputhash = sha1($outputhash.$result->hash.$result->stdout.$result->exitcode);

echo $success
	? $output->underline_green("All commands successfully executed ☃\n")
	: $output->underline_red("Some commands failed :(\n")
	;

printf("Ran %d commands in ⌚%.2fs, result hash is %s\n",
	count($results), microtime(true)-$timer, $outputhash);

exit($success ? 0 : 1);
